import { EOF } from "{{ libDir }}Automaton";
import { getBytes } from "{{ libDir }}RegexNodes";

class AutomatonData {
    constructor(nextState: number[][], accept: number[],
        nextAutomaton: Map<number, number>) {
        this.nextAutomaton = nextAutomaton;
        this.nextState = nextState;
        this.accept = accept;
    }
    // Each array is a 256-numbers array pointing to the next state.
    nextState: number[][];
    // If -1, the state is not an exit node. Otherwise, it stores the rule
    // index.
    accept: number[];
    // Maps rule indexes to new Automaton index.
    nextAutomaton: Map<number, number>;
}

const automata = [
    {{automata}}
];

export const ruleNames: string[][] = [{{names}}];
export const stateNames: string[] = [{{states}}];

export abstract class Lexer {
    constructor() {
    }
    currentAutomaton: number = 0;
    buffer: number[] = new Array();
    abstract getBytes(): number[];

    setState(name: string) {
        this.currentAutomaton = stateNames.indexOf(name);
    }

    public lex(): EOF | undefined | [{{resTypes}}, number[]];
    public lex(): EOF | undefined | [string, number[]] {
        if (this.buffer.length === 0) {
            this.buffer = this.getBytes();
            if (this.buffer.length === 0) {
                return new EOF();
            }
        }
        var pos = 0;
        var curNode = 0;
        var lastRuleMatch: number | undefined = undefined;
        var lastRuleMatchIdx = 0;

        const automaton = automata[this.currentAutomaton];
        while (pos !== this.buffer.length) {
            const nextState = automaton.nextAutomaton;
            const edge = automaton.nextState[curNode][this.buffer[pos]];
            if (edge === automaton.nextState.length) {
                break;
            }
            curNode = edge;
            if (automaton.accept[curNode] !== -1) {
                lastRuleMatch = automaton.accept[curNode]
                lastRuleMatchIdx = pos;
            }
            pos++;
            if (pos === this.buffer.length) {
                this.buffer = this.buffer.concat(this.getBytes());
            }
        }
        if (lastRuleMatch === undefined) {
            return undefined;
        }
        const matchBytes = this.buffer.splice(0, lastRuleMatchIdx + 1);
        return [ruleNames[this.currentAutomaton][lastRuleMatch], matchBytes];
    }
}